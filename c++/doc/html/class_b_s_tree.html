<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Advanced Programming Exam - Binary Search Tree: BSTree&lt; K, T, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Advanced Programming Exam - Binary Search Tree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_b_s_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BSTree&lt; K, T, C &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_b_s_t_8h_source.html">BST.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a176f1ccfb16c72f653d27c0a8a02fbb5"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a176f1ccfb16c72f653d27c0a8a02fbb5">size_of</a> () const noexcept</td></tr>
<tr class="memdesc:a176f1ccfb16c72f653d27c0a8a02fbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of the tree.  <a href="#a176f1ccfb16c72f653d27c0a8a02fbb5">More...</a><br /></td></tr>
<tr class="separator:a176f1ccfb16c72f653d27c0a8a02fbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002c1bc948d8ef1085fb53949562fc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a8002c1bc948d8ef1085fb53949562fc0">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a8002c1bc948d8ef1085fb53949562fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tree is empty.  <a href="#a8002c1bc948d8ef1085fb53949562fc0">More...</a><br /></td></tr>
<tr class="separator:a8002c1bc948d8ef1085fb53949562fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1b6b6c2b9b5a871d6ae06ba2ab174f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#add1b6b6c2b9b5a871d6ae06ba2ab174f">get_root</a> () const</td></tr>
<tr class="memdesc:add1b6b6c2b9b5a871d6ae06ba2ab174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the root node.  <a href="#add1b6b6c2b9b5a871d6ae06ba2ab174f">More...</a><br /></td></tr>
<tr class="separator:add1b6b6c2b9b5a871d6ae06ba2ab174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f5f4929f634ab6eeeed262158a407f"><td class="memItemLeft" align="right" valign="top"><a id="a31f5f4929f634ab6eeeed262158a407f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a31f5f4929f634ab6eeeed262158a407f">BSTree</a> ()=default</td></tr>
<tr class="memdesc:a31f5f4929f634ab6eeeed262158a407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="class_b_s_tree.html">BSTree</a> constructor. <br /></td></tr>
<tr class="separator:a31f5f4929f634ab6eeeed262158a407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7cc79e77368b2196be5463ce51dabb"><td class="memItemLeft" align="right" valign="top"><a id="a4c7cc79e77368b2196be5463ce51dabb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4c7cc79e77368b2196be5463ce51dabb">BSTree</a> (const K &amp;key, const T &amp;value, C comp=C{})</td></tr>
<tr class="memdesc:a4c7cc79e77368b2196be5463ce51dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_tree.html">BSTree</a> constructor accepting a key and a value, inserted as root. <br /></td></tr>
<tr class="separator:a4c7cc79e77368b2196be5463ce51dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa688700e2b3298d2c59ecb505522daf2"><td class="memItemLeft" align="right" valign="top"><a id="aa688700e2b3298d2c59ecb505522daf2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#aa688700e2b3298d2c59ecb505522daf2">BSTree</a> (const std::pair&lt; const K, T &gt; &amp;data, C comp=C{})</td></tr>
<tr class="memdesc:aa688700e2b3298d2c59ecb505522daf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_tree.html">BSTree</a> constructor accepting a std::pair&lt;key,value&gt; inserted as root. <br /></td></tr>
<tr class="separator:aa688700e2b3298d2c59ecb505522daf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875eb7debc36c3972bc9fb6b486cd64d"><td class="memItemLeft" align="right" valign="top"><a id="a875eb7debc36c3972bc9fb6b486cd64d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a875eb7debc36c3972bc9fb6b486cd64d">~BSTree</a> () noexcept=default</td></tr>
<tr class="memdesc:a875eb7debc36c3972bc9fb6b486cd64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="class_b_s_tree.html">BSTree</a> destructor. <br /></td></tr>
<tr class="separator:a875eb7debc36c3972bc9fb6b486cd64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02cf77eca992f95d44c4ada43a914c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab02cf77eca992f95d44c4ada43a914c0">BSTree</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a> &amp;t)</td></tr>
<tr class="memdesc:ab02cf77eca992f95d44c4ada43a914c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for a <a class="el" href="class_b_s_tree.html">BSTree</a>. Calls the auxiliary function <a class="el" href="class_b_s_tree.html#ad34bd4cfe46ab5a5376cc242b1901f2b" title="Auxiliary function for the copy constructor, performs a deep copy. ">copy_tree()</a> which performs a deep copy of the tree.  <a href="#ab02cf77eca992f95d44c4ada43a914c0">More...</a><br /></td></tr>
<tr class="separator:ab02cf77eca992f95d44c4ada43a914c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e883c53f2604130eeabecc73a2a95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree.html">BSTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a51e883c53f2604130eeabecc73a2a95a">operator=</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a> &amp;t)</td></tr>
<tr class="memdesc:a51e883c53f2604130eeabecc73a2a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment of a <a class="el" href="class_b_s_tree.html">BSTree</a>.  <a href="#a51e883c53f2604130eeabecc73a2a95a">More...</a><br /></td></tr>
<tr class="separator:a51e883c53f2604130eeabecc73a2a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8861897a87ab1944edbaf7754648b4"><td class="memItemLeft" align="right" valign="top"><a id="a6f8861897a87ab1944edbaf7754648b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a6f8861897a87ab1944edbaf7754648b4">BSTree</a> (<a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a6f8861897a87ab1944edbaf7754648b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor for a <a class="el" href="class_b_s_tree.html">BSTree</a>. <br /></td></tr>
<tr class="separator:a6f8861897a87ab1944edbaf7754648b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555de0952655377d903ecbc1ce6bdec3"><td class="memItemLeft" align="right" valign="top"><a id="a555de0952655377d903ecbc1ce6bdec3"></a>
<a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a555de0952655377d903ecbc1ce6bdec3">operator=</a> (<a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a555de0952655377d903ecbc1ce6bdec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment for a <a class="el" href="class_b_s_tree.html">BSTree</a>. <br /></td></tr>
<tr class="separator:a555de0952655377d903ecbc1ce6bdec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb41cae2749cded61f805bb1b902f811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#afb41cae2749cded61f805bb1b902f811">begin</a> ()</td></tr>
<tr class="memdesc:afb41cae2749cded61f805bb1b902f811"><td class="mdescLeft">&#160;</td><td class="mdescRight">first element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>.  <a href="#afb41cae2749cded61f805bb1b902f811">More...</a><br /></td></tr>
<tr class="separator:afb41cae2749cded61f805bb1b902f811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ce4b341b8503949ede9d4e6af8c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#af08ce4b341b8503949ede9d4e6af8c8b">end</a> ()</td></tr>
<tr class="memdesc:af08ce4b341b8503949ede9d4e6af8c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">last element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>  <a href="#af08ce4b341b8503949ede9d4e6af8c8b">More...</a><br /></td></tr>
<tr class="separator:af08ce4b341b8503949ede9d4e6af8c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575273bc2b272f20f8b6802f2b0a756f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a575273bc2b272f20f8b6802f2b0a756f">cbegin</a> () const</td></tr>
<tr class="memdesc:a575273bc2b272f20f8b6802f2b0a756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">first element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>.  <a href="#a575273bc2b272f20f8b6802f2b0a756f">More...</a><br /></td></tr>
<tr class="separator:a575273bc2b272f20f8b6802f2b0a756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562638580a40643c76913e51dd06c13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a562638580a40643c76913e51dd06c13b">cend</a> () const</td></tr>
<tr class="memdesc:a562638580a40643c76913e51dd06c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">last element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>  <a href="#a562638580a40643c76913e51dd06c13b">More...</a><br /></td></tr>
<tr class="separator:a562638580a40643c76913e51dd06c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23746c31f7583acad81c9b7f08159003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a23746c31f7583acad81c9b7f08159003">insert</a> (const std::pair&lt; const K, T &gt; &amp;data)</td></tr>
<tr class="memdesc:a23746c31f7583acad81c9b7f08159003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a BSTNode passing a std::pair&lt;key,value&gt;. Calls position_of(key) to find where the node should be appended. If the key is already present, does nothing. Otherwise a new node is created.  <a href="#a23746c31f7583acad81c9b7f08159003">More...</a><br /></td></tr>
<tr class="separator:a23746c31f7583acad81c9b7f08159003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ca543914dbdaa89b9c9f6fae7d6555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a00ca543914dbdaa89b9c9f6fae7d6555">insert</a> (const K &amp;key, const T &amp;value)</td></tr>
<tr class="memdesc:a00ca543914dbdaa89b9c9f6fae7d6555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a node passing a key and a value separately.  <a href="#a00ca543914dbdaa89b9c9f6fae7d6555">More...</a><br /></td></tr>
<tr class="separator:a00ca543914dbdaa89b9c9f6fae7d6555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739cf62b2b972cd063928357dd2aba9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a739cf62b2b972cd063928357dd2aba9a">find</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a739cf62b2b972cd063928357dd2aba9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns, if found, an iterator to the node labelled by key.  <a href="#a739cf62b2b972cd063928357dd2aba9a">More...</a><br /></td></tr>
<tr class="separator:a739cf62b2b972cd063928357dd2aba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5362c45ed2bc96c9c72fdef689bd078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ae5362c45ed2bc96c9c72fdef689bd078">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae5362c45ed2bc96c9c72fdef689bd078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wipes out the tree. Resets the root to nullptr, causing all the other nodes to be deleted. The tree is left uninitialized, but still usable.  <a href="#ae5362c45ed2bc96c9c72fdef689bd078">More...</a><br /></td></tr>
<tr class="separator:ae5362c45ed2bc96c9c72fdef689bd078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468dcc29b6786ddc5de05c314d644ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a468dcc29b6786ddc5de05c314d644ce1">print</a> () const</td></tr>
<tr class="memdesc:a468dcc29b6786ddc5de05c314d644ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the value in all the nodes, traversing the tree in order.  <a href="#a468dcc29b6786ddc5de05c314d644ce1">More...</a><br /></td></tr>
<tr class="separator:a468dcc29b6786ddc5de05c314d644ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955848e883b93312a467c0ee103db8df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a955848e883b93312a467c0ee103db8df">balance</a> ()</td></tr>
<tr class="memdesc:a955848e883b93312a467c0ee103db8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balances the tree.  <a href="#a955848e883b93312a467c0ee103db8df">More...</a><br /></td></tr>
<tr class="separator:a955848e883b93312a467c0ee103db8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6e522a0dbbedd33ad21724b4dca0f6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#adb6e522a0dbbedd33ad21724b4dca0f6">operator[]</a> (const K &amp;k)</td></tr>
<tr class="memdesc:adb6e522a0dbbedd33ad21724b4dca0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator [] to access/insert a BSTNode. Returns the value associated with key if found. Otherwise, appends a node with the desired key and the default value.  <a href="#adb6e522a0dbbedd33ad21724b4dca0f6">More...</a><br /></td></tr>
<tr class="separator:adb6e522a0dbbedd33ad21724b4dca0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265ffc422b631fee4e51531db590a957"><td class="memItemLeft" align="right" valign="top"><a id="a265ffc422b631fee4e51531db590a957"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const K &amp;k) const</td></tr>
<tr class="separator:a265ffc422b631fee4e51531db590a957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a7600d91dee310ece37c10cbceb6a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a8b5a7600d91dee310ece37c10cbceb6a">square_bracket_test</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a8b5a7600d91dee310ece37c10cbceb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator &lt;&lt; to print a <a class="el" href="class_b_s_tree.html">BSTree</a>.  <a href="#a8b5a7600d91dee310ece37c10cbceb6a">More...</a><br /></td></tr>
<tr class="separator:a8b5a7600d91dee310ece37c10cbceb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abf0711d0f2e62ed4a6fee153ad717833"><td class="memItemLeft" align="right" valign="top"><a id="abf0711d0f2e62ed4a6fee153ad717833"></a>
C&#160;</td><td class="memItemRight" valign="bottom"><b>compare_f</b></td></tr>
<tr class="separator:abf0711d0f2e62ed4a6fee153ad717833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab77c72f33d88ca3311286744370138bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab77c72f33d88ca3311286744370138bb">get_most_left</a> (<a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *currNode) const noexcept</td></tr>
<tr class="memdesc:ab77c72f33d88ca3311286744370138bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the leftmost element of a subtree.  <a href="#ab77c72f33d88ca3311286744370138bb">More...</a><br /></td></tr>
<tr class="separator:ab77c72f33d88ca3311286744370138bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34bd4cfe46ab5a5376cc242b1901f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ad34bd4cfe46ab5a5376cc242b1901f2b">copy_tree</a> (const <a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *currNode)</td></tr>
<tr class="memdesc:ad34bd4cfe46ab5a5376cc242b1901f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for the copy constructor, performs a deep copy.  <a href="#ad34bd4cfe46ab5a5376cc242b1901f2b">More...</a><br /></td></tr>
<tr class="separator:ad34bd4cfe46ab5a5376cc242b1901f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a386f0ffde9a0fe2e5df8562b719184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a0a386f0ffde9a0fe2e5df8562b719184">position_of</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a0a386f0ffde9a0fe2e5df8562b719184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for the insert(key, value) and find(key) methods.  <a href="#a0a386f0ffde9a0fe2e5df8562b719184">More...</a><br /></td></tr>
<tr class="separator:a0a386f0ffde9a0fe2e5df8562b719184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae6d9b52f23edb005289f52200b0b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a3ae6d9b52f23edb005289f52200b0b70">balance</a> (std::vector&lt; std::pair&lt; const K, T &gt;&gt; &amp;vine, const int &amp;<a class="el" href="class_b_s_tree.html#afb41cae2749cded61f805bb1b902f811">begin</a>, const int &amp;<a class="el" href="class_b_s_tree.html#af08ce4b341b8503949ede9d4e6af8c8b">end</a>)</td></tr>
<tr class="memdesc:a3ae6d9b52f23edb005289f52200b0b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively builds a balanced tree starting from an ordered std::vector.  <a href="#a3ae6d9b52f23edb005289f52200b0b70">More...</a><br /></td></tr>
<tr class="separator:a3ae6d9b52f23edb005289f52200b0b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa0d1b3c092ac0616ed758c37eeae28ae"><td class="memItemLeft" align="right" valign="top"><a id="aa0d1b3c092ac0616ed758c37eeae28ae"></a>
std::unique_ptr&lt; <a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> = nullptr</td></tr>
<tr class="separator:aa0d1b3c092ac0616ed758c37eeae28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a650287c9c6ac09282d0c12a34997b"><td class="memItemLeft" align="right" valign="top"><a id="a32a650287c9c6ac09282d0c12a34997b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> = 0</td></tr>
<tr class="separator:a32a650287c9c6ac09282d0c12a34997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt;<br />
class BSTree&lt; K, T, C &gt;</h3>

<p>Binary Search Tree implementation.</p>
<p>Implementation of a Binary Search Tree. The tree is made of nodes which store a key/value pair. It requires a compare structure to order keys. If none is provided, it uses std::less&lt;K&gt;, where K is the key type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab02cf77eca992f95d44c4ada43a914c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02cf77eca992f95d44c4ada43a914c0">&#9670;&nbsp;</a></span>BSTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for a <a class="el" href="class_b_s_tree.html">BSTree</a>. Calls the auxiliary function <a class="el" href="class_b_s_tree.html#ad34bd4cfe46ab5a5376cc242b1901f2b" title="Auxiliary function for the copy constructor, performs a deep copy. ">copy_tree()</a> which performs a deep copy of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="class_b_s_tree.html">BSTree</a> to be copied, passed by const reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a955848e883b93312a467c0ee103db8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955848e883b93312a467c0ee103db8df">&#9670;&nbsp;</a></span>balance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::balance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Balances the tree. </p>
<p>The tree is linearized into a vector of std::pair&lt;key,value&gt;. Then calls <a class="el" href="class_b_s_tree.html#ae5362c45ed2bc96c9c72fdef689bd078" title="Wipes out the tree. Resets the root to nullptr, causing all the other nodes to be deleted...">clear()</a> and the auxiliary function balance(vector, begin, end).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a3ae6d9b52f23edb005289f52200b0b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae6d9b52f23edb005289f52200b0b70">&#9670;&nbsp;</a></span>balance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::balance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; const K, T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteratively builds a balanced tree starting from an ordered std::vector. </p>
<p>Builds a balanced tree appending the middle element of the vector, and then iteratively calling itself to append the middle element of the two halves, with begin and end as the extremes of the halves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vine</td><td>std::vector of std::pair&lt;key, value&gt; ordered by key. </td></tr>
    <tr><td class="paramname">begin</td><td>index of the first element to be considered. </td></tr>
    <tr><td class="paramname">end</td><td>index of the last element to be considered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb41cae2749cded61f805bb1b902f811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb41cae2749cded61f805bb1b902f811">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>first element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the leftmost node. </dd></dl>

</div>
</div>
<a id="a575273bc2b272f20f8b6802f2b0a756f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575273bc2b272f20f8b6802f2b0a756f">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>first element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>constiterator to the leftmost node. </dd></dl>

</div>
</div>
<a id="a562638580a40643c76913e51dd06c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562638580a40643c76913e51dd06c13b">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>last element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a> </p>
<dl class="section return"><dt>Returns</dt><dd>cosntiterator to nullptr. </dd></dl>

</div>
</div>
<a id="ae5362c45ed2bc96c9c72fdef689bd078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5362c45ed2bc96c9c72fdef689bd078">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wipes out the tree. Resets the root to nullptr, causing all the other nodes to be deleted. The tree is left uninitialized, but still usable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ad34bd4cfe46ab5a5376cc242b1901f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34bd4cfe46ab5a5376cc242b1901f2b">&#9670;&nbsp;</a></span>copy_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::copy_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *&#160;</td>
          <td class="paramname"><em>currNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function for the copy constructor, performs a deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currNode</td><td>Pointer to the root of the subtree to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="af08ce4b341b8503949ede9d4e6af8c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08ce4b341b8503949ede9d4e6af8c8b">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>last element for iterating a <a class="el" href="class_b_s_tree.html">BSTree</a> </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to nullptr. </dd></dl>

</div>
</div>
<a id="a739cf62b2b972cd063928357dd2aba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739cf62b2b972cd063928357dd2aba9a">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::<a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns, if found, an iterator to the node labelled by key. </p>
<p>Calls the auxiliary function position_of(key) which returns, if key is found, an iterator pointing to the node that contains key. If the key is not found or the <a class="el" href="class_b_s_tree.html">BSTree</a> is empty, retuns a <a class="el" href="class_b_s_tree_1_1_const_iterator.html">ConstIterator</a> to nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a> to the node containing the requested key or to nullptr. </dd></dl>

</div>
</div>
<a id="ab77c72f33d88ca3311286744370138bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77c72f33d88ca3311286744370138bb">&#9670;&nbsp;</a></span>get_most_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; * <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::get_most_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt; K, T &gt; *&#160;</td>
          <td class="paramname"><em>currNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the leftmost element of a subtree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currNode</td><td>The root node of the subtree to be considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the leftmost element. </dd></dl>

</div>
</div>
<a id="add1b6b6c2b9b5a871d6ae06ba2ab174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1b6b6c2b9b5a871d6ae06ba2ab174f">&#9670;&nbsp;</a></span>get_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_node_namespace_1_1_b_s_t_node.html">BSTNode</a>&lt;K,T&gt;* <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::get_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to root BSTNode. </dd></dl>

</div>
</div>
<a id="a23746c31f7583acad81c9b7f08159003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23746c31f7583acad81c9b7f08159003">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const K, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a BSTNode passing a std::pair&lt;key,value&gt;. Calls position_of(key) to find where the node should be appended. If the key is already present, does nothing. Otherwise a new node is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pair of key-value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Boolean which is true if a new node was inserted, false if the key was already present. </dd></dl>

</div>
</div>
<a id="a00ca543914dbdaa89b9c9f6fae7d6555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ca543914dbdaa89b9c9f6fae7d6555">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a node passing a key and a value separately. </p>
<p>Key and value are grouped in an std::pair&lt;key, value&gt;, <a class="el" href="class_b_s_tree.html#a23746c31f7583acad81c9b7f08159003" title="Inserts a BSTNode passing a std::pair&lt;key,value&gt;. Calls position_of(key) to find where the node shoul...">insert()</a> is then called passing the std::pair&lt;key,value&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key entry of the node. </td></tr>
    <tr><td class="paramname">value</td><td>content associated to key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a8002c1bc948d8ef1085fb53949562fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8002c1bc948d8ef1085fb53949562fc0">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the tree is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the tree is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a51e883c53f2604130eeabecc73a2a95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e883c53f2604130eeabecc73a2a95a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment of a <a class="el" href="class_b_s_tree.html">BSTree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the <a class="el" href="class_b_s_tree.html">BSTree</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly copied <a class="el" href="class_b_s_tree.html">BSTree</a>. </dd></dl>

</div>
</div>
<a id="adb6e522a0dbbedd33ad21724b4dca0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6e522a0dbbedd33ad21724b4dca0f6">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator [] to access/insert a BSTNode. Returns the value associated with key if found. Otherwise, appends a node with the desired key and the default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>key to be found/inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value associated with the key k. </dd></dl>

</div>
</div>
<a id="a0a386f0ffde9a0fe2e5df8562b719184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a386f0ffde9a0fe2e5df8562b719184">&#9670;&nbsp;</a></span>position_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::<a class="el" href="class_b_s_tree_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::position_of </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function for the insert(key, value) and find(key) methods. </p>
<p>If the requested key is present, returns and iterator pointing to the node that contains it (exploited by find(key)). Otherwise, it returns an iterator pointing to the node N. The key should be contained in a node inserted as a child of N (exploited by the insert(key,value)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to node required. </dd></dl>

</div>
</div>
<a id="a468dcc29b6786ddc5de05c314d644ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468dcc29b6786ddc5de05c314d644ce1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the value in all the nodes, traversing the tree in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a176f1ccfb16c72f653d27c0a8a02fbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176f1ccfb16c72f653d27c0a8a02fbb5">&#9670;&nbsp;</a></span>size_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename C = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::size_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const int&amp; Number of elements of the tree. </dd></dl>

</div>
</div>
<a id="a8b5a7600d91dee310ece37c10cbceb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5a7600d91dee310ece37c10cbceb6a">&#9670;&nbsp;</a></span>square_bracket_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; K, T, C &gt;::square_bracket_test </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator &lt;&lt; to print a <a class="el" href="class_b_s_tree.html">BSTree</a>. </p>
<p>Iterates the tree using const iterators and prints "key: value" for each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>OutputStream, where the content of the <a class="el" href="class_b_s_tree.html">BSTree</a> should be printed. </td></tr>
    <tr><td class="paramname">t</td><td>Const reference to the <a class="el" href="class_b_s_tree.html">BSTree</a> to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the OutputStream.</dd></dl>
<p>Test function for const[] operator</p>
<p>Trivial function declared as const which calls the const[] operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to be searched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/w-wilson/DSSC/first_year/exam_advanced/test/include/<a class="el" href="_b_s_t_8h_source.html">BST.h</a></li>
<li>/home/w-wilson/DSSC/first_year/exam_advanced/test/src/<a class="el" href="_b_s_t_8hpp_source.html">BST.hpp</a></li>
<li>/home/w-wilson/DSSC/first_year/exam_advanced/test/src/<a class="el" href="main_8cc.html">main.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
